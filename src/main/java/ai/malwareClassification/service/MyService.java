package ai.malwareClassification.service;

import ai.malwareClassification.config.auth.PrincipalDetails;
import ai.malwareClassification.controller.NewfileDTO;
import ai.malwareClassification.domain.Software;
import ai.malwareClassification.repository.SoftwareRepository;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.codec.binary.Hex;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.security.MessageDigest;
import java.util.Optional;
import java.util.UUID;

@Slf4j
@Service
public class MyService {
    private final SoftwareRepository softwareRepository;
    public MyService(SoftwareRepository softwareRepository) {
        this.softwareRepository = softwareRepository;
    }

    private String saveInLocalStorage(MultipartFile file, String signature, String path){
        String uploadFilename = signature + '_' + file.getOriginalFilename();

        if (!path.equals(LocalStorage.tmp_path)){
            String uuid = UUID.randomUUID().toString();
            uploadFilename = uuid + '_' + uploadFilename;
        }

        String filePath = path + uploadFilename; //경로

        File dest = new File(filePath);
        try {
            file.transferTo(dest); // 파일 업로드 작업 수행
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return filePath;
    }

    public String createSignature(MultipartFile file) throws Exception {
        MessageDigest messageDigest = MessageDigest.getInstance("MD5");
        byte[] dataBytes = file.getBytes();
        messageDigest.update(dataBytes);
        String signature = Hex.encodeHexString(messageDigest.digest()); // 시그니처 생성
        return signature;
    }


    @Transactional
    public SaveSignatureAndFileDTO saveSignatureAndFile(NewfileDTO newfileDTO, PrincipalDetails userDetails) throws Exception {
        MultipartFile file = newfileDTO.getFile();
        String signature = createSignature(file);
        Optional<Software> result = softwareRepository.findBySignature(signature);
        SaveSignatureAndFileDTO saveSignatureAndFileDTO = new SaveSignatureAndFileDTO(false, signature);
        result.ifPresentOrElse(
                sw -> {
                    saveSignatureAndFileDTO.setInDB(true);
                    log.info("이미 있음");
                },
                () -> {
                    String path = saveInLocalStorage(file, signature, LocalStorage.tmp_path);
                    Software software = new Software();
                    software.setSignature(signature);
                    software.setPath(path);
                    software.setFirst_name(file.getOriginalFilename());
                    software.setUploader_name(userDetails.getUsername());
                    software.setNickname(null);
                    softwareRepository.save(software);
                }
        );
        return saveSignatureAndFileDTO;
    }

}